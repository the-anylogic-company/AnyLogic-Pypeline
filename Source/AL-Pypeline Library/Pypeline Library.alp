<?xml version="1.0" encoding="UTF-8"?>
<!--
*************************************************
	         AnyLogic Project File 
*************************************************	         
-->
<AnyLogicWorkspace WorkspaceVersion="1.9" AnyLogicVersion="8.7.0.202011181904" AlpVersion="8.7.0">
<Model>
	<Id>1567802082268</Id>
	<Name><![CDATA[Pypeline Library]]></Name>
	<Description><![CDATA[The library for being able to run Python within an AnyLogic model]]></Description>
	<EngineVersion>6</EngineVersion>
	<JavaPackageName><![CDATA[com.anylogic.libraries.pypeline]]></JavaPackageName>
	<ModelTimeUnit><![CDATA[Second]]></ModelTimeUnit>
	<OptionLists>
		<OptionList>
			<Id>1574961034301</Id>
			<Name><![CDATA[PythonCommandType]]></Name>
			<Option>
				<Id>1574961050485</Id>
				<Name><![CDATA[PYTHON]]></Name>
			</Option>
			<Option>
				<Id>1574961045397</Id>
				<Name><![CDATA[PYTHON2]]></Name>
			</Option>
			<Option>
				<Id>1574961047949</Id>
				<Name><![CDATA[PYTHON3]]></Name>
			</Option>
			<Option>
				<Id>1574961034631</Id>
				<Name><![CDATA[PYTHON_OTHER]]></Name>
			</Option>
			<Option>
				<Id>1589489938747</Id>
				<Name><![CDATA[PYTHON_PATH]]></Name>
			</Option>
		</OptionList>
	</OptionLists>
	<ActiveObjectClasses>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1569858524855</Id>
			<Name><![CDATA[PyCommunicator]]></Name>
			<Description><![CDATA[<h4>Python Communicator</h4>
<h5>Dragging this agent into a model allows you to run Python code as part of your model.</h5>

Available functions, with name and description:<br>
(See code completion for more info)<br>
<table border="1">
  <tr>
    <td><code>isConnected</code></td>
    <td style="font-size:12">Pings the server to check if it's still alive</td>
  </tr>
  <tr>
    <td><code>run</code></td>
    <td style="font-size:12">Execute a statement (return void)</td>
  </tr>
  <tr>
    <td><code>runResults</code></td>
    <td style="font-size:12">Evaluation an expression (return some results)</td>
  </tr>
  <tr>
	<td><code>runFile</code></td>
	<td style="font-size:12">Runs a file and returns the output. Can be used as part of an active object or staticly.</td>
  </tr>
</table>
Note 1: all calls return an <code>Attempt</code> object. <br>
You can query the success and feedback using the <code>isSuccessful</code> and <code>getFeedback</code> functions.<br>
<br>
In addition to single-line Python code, you can also pass multiline Python code in the form of multiple arguments<br>
Note 2: For multiline code, make sure all the number of spaces you use for each indentation are consistent.<br>
<br>
Node 3: A history of recently ran commands  can be accessed through the variable <code>history</code> located within this object.]]></Description>
			<AdditionalClassCode><![CDATA[private static final String[][] condaPaths = new String[][]{
	{"Library", "mingw-w64", "bin"},
	{"Library", "usr", "bin"},
	{"Library", "bin"},
	{"Scripts"},
	{"bin"}
};

private static List<Class<?>> classesToIgnore = Arrays.asList(
	Color.class,
	Font.class,
	Shape.class,
	EventOriginator.class,
	Statechart.class,
	IStatechartState.class,
	AbstractLinkToAgent.class,
	Scale.class,
	CustomDistribution.class
	);
private static List<String> pkgNamesToIgnore = Arrays.asList(
	"com.anylogic.libraries.pypeline",
	"com.anylogic.libraries.processmodeling",
	"com.anylogic.libraries.material_handling",
	"com.anylogic.libraries.pedestrian",
	"com.anylogic.libraries.rail",
	"com.anylogic.libraries.road",
	"com.anylogic.libraries.fluid",
	"com.anylogic.engine.markup",
	"com.anylogic.engine.connectivity",
	"com.anylogic.engine.presentation"
	);
public static boolean skipJsonifying(Class<?> clazz) {
	if (pkgNamesToIgnore.contains(clazz.getPackageName()))
		return true;
	for (Class<?> clsToIgnore : classesToIgnore) {
		if (clsToIgnore.isAssignableFrom(clazz)) {
			return true;
		}
	}
	return false;
}

/**
Initialize PyCommunicator object based on whether to load from properties.
*/
public PyCommunicator(boolean loadLastWorkingConfig) {
	this(loadLastWorkingConfig, null, null, null, true, true);
}

/**
Initialize PyCommunicator object from the preferred version.
Only applicable when using `PYTHON_AUTO`, `PYTHON_2` or `PYTHON_3`.
Defaults to throwing error on failed attempt.
Defaults to redirect Python output.
*/
public PyCommunicator(PythonCommandType pythonCommandType) {
	this(false, pythonCommandType, "", "", true, true);
}

/**
Initialize PyCommunicator object from the preferred version.
Only applicable when using `PYTHON_AUTO`, `PYTHON_2` or `PYTHON_3`.
*/
public PyCommunicator(PythonCommandType pythonCommandType, boolean throwErrorOnFailedAttempt, boolean redirectPyOutput) {
	this(false, pythonCommandType, "", "", throwErrorOnFailedAttempt, redirectPyOutput);
}

/**
Initialize PyCommunicator object from the preferred version and argument.
Only applicable when using `PYTHON_OTHER` or `PYTHON_PATH`.
Defaults to throwing error on failed attempt.
Defaults to redirect Python output.
*/
public PyCommunicator(PythonCommandType pythonCommandType, String otherCommandOrPath) {
	this(false, 
		pythonCommandType, 
		pythonCommandType.equals(PYTHON_OTHER) ? otherCommandOrPath : null, 
		pythonCommandType.equals(PYTHON_PATH) ? otherCommandOrPath : null, 
		true,
		true);
}

/**
Initialize PyCommunicator object from the preferred version and an argument.
Only applicable when using `PYTHON_OTHER` or `PYTHON_PATH`.
*/
public PyCommunicator(PythonCommandType pythonCommandType, String otherCommandOrPath, boolean throwErrorOnFailedAttempt, boolean redirectPyOutput) {
	this(false, 
		pythonCommandType, 
		pythonCommandType.equals(PYTHON_OTHER) ? otherCommandOrPath : null, 
		pythonCommandType.equals(PYTHON_PATH) ? otherCommandOrPath : null, 
		throwErrorOnFailedAttempt,
		redirectPyOutput);
}



static HashMap<String, Object> serializeHistogram1DData(HistogramData h1data) {
	HashMap<String, Object> dataTable = new HashMap<>();

	int count = h1data.count();
	dataTable.put("count", count);
	// Follow similar structure as in ALCloud: User can derive ranges based on min X and interval width
	dataTable.put("lowerBound", h1data.getXMin());
	dataTable.put("intervalWidth", h1data.getIntervalWidth());
	int[] hits = IntStream.range(0, h1data.getNumberOfIntervals())
			.map(i -> Math.round((float)h1data.getPDF(i)*count)).toArray();
	dataTable.put("hits", hits);
	// HSimpleData = User set explicit min/max. There may be data outside this range, so add counts of lower/upper range of interval
	if (h1data instanceof HistogramSimpleData) {
		HistogramSimpleData hdataSimple = (HistogramSimpleData) h1data;
		dataTable.put("hitsOutLow", Math.round((float)hdataSimple.getPDFOutsideLow()*count));
		dataTable.put("hitsOutHigh", Math.round((float)hdataSimple.getPDFOutsideHigh()*count));
	}
	// Add in other useful stats available from histogram
	HashMap<String, Double> dtableStats = new HashMap<>();
	dtableStats.put("min", h1data.min());
	dtableStats.put("max", h1data.max());
	dtableStats.put("mean", h1data.mean());
	dtableStats.put("deviation", h1data.deviation());
	dataTable.put("statistics", dtableStats);
	
	return dataTable;
	
}

static HashMap<String, Object> serializeHistogram2DData(Histogram2DData h2data) {
	HashMap<String, Object> dataTable = new HashMap<>();

	// Follow similar structure as in ALCloud; user can derive interval size, etc. from available data
	int nX = h2data.getNumberOfXIntervals();
	int nY = h2data.getNumberOfYIntervals();
	int[][] hits = new int[nY][nX];
	int[] hitsOutLow = new int[nX];
	int[] hitsOutHigh = new int[nX];
	for (int x = 0; x < nX; x++) {
		int xcount = h2data.count(x);
		hitsOutLow[x] = Math.round((float)h2data.getPDFOutsideLow(x)*xcount);
		hitsOutHigh[x] = Math.round((float)h2data.getPDFOutsideHigh(x)*xcount);
		for (int y = 0; y < nY; y++) {
			hits[y][x] = Math.round((float)h2data.getPDF(x, y)*xcount);
		}
	}
	dataTable.put("hits", hits);
	dataTable.put("hitsOutLow", hitsOutLow);
	dataTable.put("hitsOutHigh", hitsOutHigh);
	dataTable.put("xMin", h2data.getXMin());
	dataTable.put("xMax", h2data.getXMax());
	dataTable.put("yMin", h2data.getYMin());
	dataTable.put("yMax", h2data.getYMax());
	return dataTable;
}

static HashMap<String, Object> serializeStatisticsDiscrete(StatisticsDiscrete stat) {
	String[] statRows = stat.toString().split("\n");
	HashMap<String, Object> statMap = new HashMap<>();
	Arrays.stream(statRows)
		.map(s -> s.strip().split("\t"))
		.forEach(s -> statMap.put(s[0], Double.valueOf(s[1])));
	return statMap;
}

static HashMap<String, Object> serializeStatisticsContinuous(StatisticsContinuous stat) {
	String[] statRows = stat.toString().split("\n");
	HashMap<String, Object> statMap = new HashMap<>();
	Arrays.stream(statRows)
		.map(s -> s.strip().split("\t"))
		.forEach(s -> statMap.put(s[0], Double.valueOf(s[1])));
	return statMap;
}
]]></AdditionalClassCode>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<Import><![CDATA[import java.nio.file.Files;
import java.io.IOException;
import java.io.FileWriter;
import java.io.BufferedWriter;
import java.io.File;
import spark.utils.IOUtils;
import java.util.Properties;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.OutputStream;
import java.io.FileOutputStream;
import java.net.URISyntaxException;
import java.nio.file.Paths;
import java.net.URI;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Field;
import java.io.FileNotFoundException;
import com.anylogic.cloud.util.ExceptionUtils;
import java.util.stream.IntStream;]]></Import>
			<StartupCode><![CDATA[initialize();
generateProperties();]]></StartupCode>
			<DestroyCode><![CDATA[// Allow the existing Python environment to die gracefully
try {
	py.close();
} catch (Exception e) {
	e.printStackTrace();
}]]></DestroyCode>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1569858524853</Id>
				<Name><![CDATA[1569858524853]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowchartBlock>true</FlowchartBlock>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<SceneSkybox>null</SceneSkybox>
			<AgentProperties>
	 			<SpaceType>CONTINUOUS</SpaceType>			
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>false</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1569916800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1569858524851</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<CurrentLevel>1569858524854</CurrentLevel>
			<ConnectionsId>1569858524850</ConnectionsId>
			<Variables>
				<Variable Class="PlainVariable">
					<Id>1569878540323</Id>
					<Name><![CDATA[py]]></Name>
					<Description><![CDATA[An instance of the <code>PySubProcess</code> object]]></Description>
					<X>300</X><Y>50</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="false">
						<Type><![CDATA[PySubProcess]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[null]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1574960246472</Id>
					<Name><![CDATA[PYTHON]]></Name>
					<X>80</X><Y>120</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="true" AccessType="public" StaticVariable="true">
						<Type><![CDATA[PythonCommandType]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[PythonCommandType.PYTHON]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1574960293631</Id>
					<Name><![CDATA[PYTHON2]]></Name>
					<X>80</X><Y>150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="true" AccessType="public" StaticVariable="true">
						<Type><![CDATA[PythonCommandType]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[PythonCommandType.PYTHON2]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1574960297045</Id>
					<Name><![CDATA[PYTHON3]]></Name>
					<X>80</X><Y>180</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="true" AccessType="public" StaticVariable="true">
						<Type><![CDATA[PythonCommandType]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[PythonCommandType.PYTHON3]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1574960298125</Id>
					<Name><![CDATA[PYTHON_OTHER]]></Name>
					<X>80</X><Y>210</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="true" AccessType="public" StaticVariable="true">
						<Type><![CDATA[PythonCommandType]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[PythonCommandType.PYTHON_OTHER]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1589490530972</Id>
					<Name><![CDATA[PYTHON_PATH]]></Name>
					<X>80</X><Y>240</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="true" AccessType="public" StaticVariable="true">
						<Type><![CDATA[PythonCommandType]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[PythonCommandType.PYTHON_PATH]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1589586802472</Id>
					<Name><![CDATA[PROPERTIES_FILENAME]]></Name>
					<X>-150</X><Y>450</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="true" AccessType="public" StaticVariable="false">
						<Type><![CDATA[String]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA["pypeline.properties"]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1597361797787</Id>
					<Name><![CDATA[objmapper]]></Name>
					<Description><![CDATA[An instance of Jackson's `ObjectMapper` class; used in the `toJson` and `fromJson` functions.]]></Description>
					<X>300</X><Y>350</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="true">
						<Type><![CDATA[ObjectMapper]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ObjectMapper()]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="Parameter">
					<Id>1589488014296</Id>
					<Name><![CDATA[loadLastWorkingConfig]]></Name>
					<X>50</X><Y>50</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[false]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1589488014294</Id>
							<Label><![CDATA[Load last working configuration]]></Label>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1570726491560</Id>
					<Name><![CDATA[pythonCommandType]]></Name>
					<Description><![CDATA[The preferred command to call Python.<br>
If <i>(other)</i> is selected, you can specify the alias to Python.<br>
If <i>(path)</i> is selected, you can specify the full path to the desired python executable.
]]></Description>
					<X>50</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[com.anylogic.libraries.pypeline.PythonCommandType]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[self.PYTHON]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1570726491558</Id>
							<Label><![CDATA[Command to call Python]]></Label>
							<EditorContolType>RADIO_BUTTONS</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1589488014296</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</HideCondition>
							<PredefParamValue>
								<Id>0</Id>
								<Name><![CDATA[python]]></Name>
								<Value Class="CodeValue">
									<Code><![CDATA[self.PYTHON]]></Code>
								</Value>
							</PredefParamValue>
							<PredefParamValue>
								<Id>0</Id>
								<Name><![CDATA[python3]]></Name>
								<Value Class="CodeValue">
									<Code><![CDATA[self.PYTHON3]]></Code>
								</Value>
							</PredefParamValue>
							<PredefParamValue>
								<Id>0</Id>
								<Name><![CDATA[(other)]]></Name>
								<Value Class="CodeValue">
									<Code><![CDATA[self.PYTHON_OTHER]]></Code>
								</Value>
							</PredefParamValue>
							<PredefParamValue>
								<Id>0</Id>
								<Name><![CDATA[(path)]]></Name>
								<Value Class="CodeValue">
									<Code><![CDATA[self.PYTHON_PATH]]></Code>
								</Value>
							</PredefParamValue>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>SEPARATOR</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1589488235619</Id>
					<Name><![CDATA[pythonCommand]]></Name>
					<Description><![CDATA[The full path to the desired python executable.<br>]]></Description>
					<X>50</X><Y>270</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[String]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[// e.g., "python38"]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1589488235617</Id>
							<Label><![CDATA[Python command]]></Label>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<HideCondition>
								<Id>1589488235615</Id>
								<ParameterId>1570726491560</ParameterId>
								<Operation>NOT_EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[self.PYTHON_OTHER]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>1589488235616</Id>
								<ParameterId>1589488014296</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1578675862658</Id>
					<Name><![CDATA[pythonExecPath]]></Name>
					<Description><![CDATA[The full path to the desired python executable.<br>]]></Description>
					<X>50</X><Y>310</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[String]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[// e.g., "C:\\Program Files\\Python37\\python.exe"]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1578675862656</Id>
							<Label><![CDATA[Python executable path]]></Label>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1570726491560</ParameterId>
								<Operation>NOT_EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[self.PYTHON_PATH]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1589488014296</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1582299117563</Id>
					<Name><![CDATA[throwErrorOnFailedAttempt]]></Name>
					<Description><![CDATA[Decides whether to throw an AnyLogic model error if any command does not execute successfully.<br>]]></Description>
					<X>50</X><Y>350</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1582299117561</Id>
							<Label><![CDATA[Throw error on failed attempt]]></Label>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1589488014296</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1597358663336</Id>
					<Name><![CDATA[redirectPyOutput]]></Name>
					<Description><![CDATA[Whether to redirect output coming from Python to the AnyLogic console.<br>
If true, anything sent by Python to the standard output (e.g., print statements) or non-halting standard error (e.g., warnings) will be printed to the AnyLogic console.<br>
When viewed from the developer panel, standard output will be printed in <span style="color:green;">green</span> and standard error will be printed in <span style="color:red;">red</span>.<br>]]></Description>
					<X>50</X><Y>390</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1597358663334</Id>
							<Label><![CDATA[Redirect Python output]]></Label>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1589488014296</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="CollectionVariable">
					<Id>1573064066321</Id>
					<Name><![CDATA[history]]></Name>
					<Description><![CDATA[Holds the last 500 commands ran by the user, in chronological order (i.e., the first item is the most recently run command).<br>
Implemented as a list of <code>Pair</code> objects with the command as the first value and the <code>Attempt</code> as the second value.<br>
For example, to get the code used in the most recent command: <code>history.get(0).getFirst()</code><br>
And to get the Attempt used in the most recent command: <code>history.get(0).getSecond()</code><br>
<br>
Provided as reference for the end-user; for example, if they execute multiple commands sequentially and want the outputs without having to create an object for each call.<br>]]></Description>
					<X>450</X><Y>50</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" AccessType="public" StaticVariable="false">
						<CollectionClass><![CDATA[LinkedList]]></CollectionClass>
						<ElementClass><![CDATA[Pair<String, Attempt>]]></ElementClass>
						<ValueElementClass><![CDATA[String]]></ValueElementClass>
					</Properties>

				</Variable>
				<Variable Class="CollectionVariable">
					<Id>1575321216484</Id>
					<Name><![CDATA[serverPyLines]]></Name>
					<Description><![CDATA[This file is written in the system's temporary file directory and how Python communicates with AnyLogic.]]></Description>
					<X>750</X><Y>50</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>false</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" AccessType="private" StaticVariable="false">
						<CollectionClass><![CDATA[ArrayList]]></CollectionClass>
						<ElementClass><![CDATA[String]]></ElementClass>
						<ValueElementClass><![CDATA[String]]></ValueElementClass>
						<CollectionInitializer Class="CodeValue">
							<Code><![CDATA[{
"import os",
"import socket",
"import sys",
"import json",
"from json.decoder import JSONDecodeError",
"import struct",
"",
"LEN_SIZE = 10",
"TYPE_SIZE = 1",
"",
"# In",
"EXEC_MSG = 0",
"EVAL_MSG = 1",
"PING_MSG = 2",
"",
"# Out",
"SUCC_MSG = 0",
"ERR_MSG = 1",
"EMPTY_RESULT = ''",
"",
"def print_err(s):",
"    sys.stderr.write('{}\\n'.format(s))",
"    sys.stderr.flush()",
"",
"class ConnectionReader:",
"    def __init__(self, conn):",
"        self.conn = conn",
"        self.buff = bytearray()",
"",
"    def _get_packet(self):",
"        data = self.conn.recv(1024)",
"        if not data:",
"            raise EOFError('Connection closed')",
"        return data",
"",
"    def read(self, size):",
"        while len(self.buff) < size:",
"            self.buff.extend(self._get_packet())",
"        result = bytes(self.buff[:size])",
"        del self.buff[:size]",
"        return result",
"",
"    def read_json(self):",
"        return json.loads(r'{}'.format(self.read_string()))",
"",
"    def read_int(self):",
"        return struct.unpack('>i', self.read(4))[0]",
"",
"    def read_byte(self):",
"        return struct.unpack('b', self.read(1))[0]",
"",
"    def read_string(self):",
"        length = self.read_int()",
"        return self.read(length).decode('utf-8')",
"",
"",
"class ConnectionWriter:",
"    def __init__(self, conn):",
"        self.conn = conn",
"        self.buff = bytearray()",
"",
"    def write(self, data):",
"        self.buff.extend(data)",
"",
"    def write_byte(self, b):",
"        self.write(struct.pack('b', b))",
"",
"    def write_int(self, i):",
"        self.write(struct.pack('>i', i))",
"",
"    def write_string(self, s):",
"        bs = to_bytes(s)",
"        self.write_int(len(bs))",
"        self.write(bs)",
"",
"    def flush(self):",
"        self.conn.sendall(self.buff)",
"        self.clear()",
"",
"    def clear(self):",
"        self.buff = bytearray()",
"",
"",
"def utf8(bs):",
"    if sys.version_info >= (3, 0):",
"        return str(bs, 'UTF8')",
"    return unicode(bs, 'UTF8')",
"",
"",
"def to_bytes(s):",
"    if type(s) == bytes:",
"        return s",
"",
"    if type(s) != str:",
"        s = str(s)",
"",
"    if sys.version_info >= (3, 0):",
"        return bytes(s, 'UTF8')",
"    return bytes(s)",
"",
"",
"def responder():",
"    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
"    try:",
"        sock.bind(('localhost', 0))",
"        sock.listen(0)",
"        _, port = sock.getsockname()",
"        sys.stdout.write('{}\\n'.format(port))",
"        sys.stdout.flush()",
"        conn, addr = sock.accept()",
"        try:",
"            inp = ConnectionReader(conn)",
"            out = ConnectionWriter(conn)",
"            globs = {}",
"            while True:",
"                msg_type = int(inp.read_byte())",
"                try:",
"                    if msg_type == EXEC_MSG: # 0 (just run)",
"                        code = inp.read_string()",
"                        exec(code, globs)",
"                        out.write_byte(SUCC_MSG)",
"                        out.write_string(EMPTY_RESULT)",
"                    elif msg_type == EVAL_MSG: # 1 (run and return)",
"                        code = inp.read_string()",
"                        try:",
"                            result = eval(code, globs)",
"                        except NameError as n_err: # assume json",
"                            try:",
"                                result = json.loads(r'{}'.format(code))",
"                            except JSONDecodeError as j_err:",
"                                raise Exception('The following line failed to parse (as strictly Python or JSON-parsed code):'",
"                                                + '\\n    `{}`'.format(code)",
"												 + '\\nConsider one of the following reasons:'",
"                                                + '\\n1. Python reason: {}'.format(n_err)",
"                                                + '\\n2. JSON   reason: {}'.format(j_err))",
"                        out.write_byte(SUCC_MSG)",
"                        out.write_string(result)",
"                    elif msg_type == PING_MSG: # 2 (testing)",
"                        out.write_byte(SUCC_MSG)",
"                        out.write_string(EMPTY_RESULT)",
"                    else:",
"                        raise Exception('Unrecognized message type: {}'.format(msg_type))",
"                except Exception as e:",
"                    out.write_byte(ERR_MSG)",
"                    out.write_string(repr(e))",
"                finally:",
"                    out.flush()",
"                    flush()",
"        finally:",
"            conn.close()",
"    finally:",
"        sock.close()",
"",
"def flush():",
"    sys.stdout.flush()",
"    sys.stderr.flush()",
"",
"if __name__ == '__main__':",
"    sys.path.insert(0, os.getcwd())",
"    responder()",
""
}]]></Code>
						</CollectionInitializer>
					</Properties>

				</Variable>
			</Variables>
			<Functions>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Attempt]]></ReturnType>
					<Id>1569878590739</Id>
					<Name><![CDATA[run]]></Name>
					<Description><![CDATA[ Execute a statement ("just run" / no expected return)<br>
@param code the single line of code to be executed<br>
@return Attempt Contains no feedback if successful, otherwise the error message]]></Description>
					<X>600</X><Y>50</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[code]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[Attempt attempt = py.exec(code);
history.add(0, new Pair<>(code, attempt));
validateHistoryLimit();
if (throwErrorOnFailedAttempt && !attempt.isSuccessful()) {
	error(attempt.getFeedback()); // new lines aren't printing properly, TODO - look into that
}
return attempt;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Attempt]]></ReturnType>
					<Id>1569878595053</Id>
					<Name><![CDATA[run]]></Name>
					<Description><![CDATA[ Execute a statement ("just run" / no expected return)<br>
@param lines the multi-lined code to run, with each line as its own argument<br>
@return Attempt Contains no feedback if successful, otherwise the error message]]></Description>
					<X>630</X><Y>80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[lines]]></Name>
						<Type><![CDATA[String...]]></Type>
					</Parameter>
					<Body><![CDATA[String code = String.join("\n", lines);
return run(code);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Attempt]]></ReturnType>
					<Id>1569878710125</Id>
					<Name><![CDATA[runResults]]></Name>
					<Description><![CDATA[Evaluate an expression ("get value" / expecting a return)<br>
@param code the single line of code to be executed<br>
@return Attempt Contains the feedback of the returned value if no error, otherwise the error message]]></Description>
					<X>600</X><Y>150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[code]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[Attempt attempt = py.eval(code);
history.add(0, new Pair<>(code, attempt));
validateHistoryLimit();
if (throwErrorOnFailedAttempt && !attempt.isSuccessful())
	error(attempt.getFeedback());
return attempt;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Attempt]]></ReturnType>
					<Id>1569878750550</Id>
					<Name><![CDATA[runResults]]></Name>
					<Description><![CDATA[Evaluate an expression ("get value" / expecting a return)<br>
@param lines The multi-lined code to run, with each line as its own argument<br>
@return Attempt Contains the feedback of the returned value if no error, otherwise the error message]]></Description>
					<X>630</X><Y>180</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[lines]]></Name>
						<Type><![CDATA[String...]]></Type>
					</Parameter>
					<Body><![CDATA[String code = String.join("\n", lines);
return runResults(code);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[boolean]]></ReturnType>
					<Id>1572989835347</Id>
					<Name><![CDATA[isConnected]]></Name>
					<Description><![CDATA[Attempts to ping the Python server to see if it's still alive and ready to receive commands<br>
@return boolean whether the ping was successful]]></Description>
					<X>600</X><Y>500</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[Attempt attempt = py.ping();

if (throwErrorOnFailedAttempt && !attempt.isSuccessful())
	error(attempt.getFeedback());

return attempt.isSuccessful();]]></Body>
				</Function>
				<Function AccessType="private" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1575321216486</Id>
					<Name><![CDATA[createServerPy]]></Name>
					<Description><![CDATA[Creates the server Python file
@return String Path to the server file]]></Description>
					<X>750</X><Y>100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>false</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[try {
	java.nio.file.Path tmpFile = Files.createTempFile("pypeline-server_", ".py");
	tmpFile.toFile().deleteOnExit();
	BufferedWriter writer = new BufferedWriter(new FileWriter(tmpFile.toFile()));
	for (String line : serverPyLines)
    	writer.write(line + "\n");
    writer.close();
	return tmpFile.toString();
} catch (IOException e) {
	e.printStackTrace();
}
return null;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1581007322208</Id>
					<Name><![CDATA[toString]]></Name>
					<X>-100</X><Y>50</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[return py == null ? "null" : py.activePyVersion + "\n" + py.activePyPath;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1581016103424</Id>
					<Name><![CDATA[initialize]]></Name>
					<Description><![CDATA[Uses the currently set value for the preferred Python version (and optionally, the path to the executable) to initialize the Python environment.<br>
If there is already a running Python environment, this will first try to close it gracefully before creating a new environment.]]></Description>
					<X>300</X><Y>100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[// Allow the existing Python environment (if one is created) to die gracefully
if (py != null) {
	try {
		py.close();
	} catch (Exception e) {
		e.printStackTrace();
	}
}

if (loadLastWorkingConfig) {
	importProperties();
}

// Synchronize parameters based on provided parameters
String pathToServerPy = createServerPy();
switch (pythonCommandType) {
	case PYTHON:
	case PYTHON2:
	case PYTHON3:
		set_pythonCommand(PySubProcess.convertToCommand(pythonCommandType));
	case PYTHON_OTHER:
		try {
			set_pythonExecPath(PySubProcess.findPythonPath(pythonCommand));
		} catch (PyException e) {
			error(e, "Failed to find Python executable path based on Python command: " + String.format(pythonCommand));
		}
	case PYTHON_PATH:
		break;
}

if (pythonExecPath == null) {
	String msg = "Could not find any Python executable based on your preferred input (" + pythonCommandType + ")";
	msg += "\nNOTE: Please check your system PATH. This can be printed out in AnyLogic by executing the code: `traceln(System.getenv(\"PATH\"));`";
	error(msg);
}

File f = new File(pythonExecPath);
if (!f.exists()) {
	// handle when path does not exist
	String msg = "No Python executable is located at: " + pythonExecPath;
	msg += "\nConsult the user guide for more information.";
	if (pythonExecPath.contains("Microsoft\\WindowsApps")) {
		msg += "\nNOTE: The `python3` command is tied to the MS version of Python (which you don't have installed)."
				+ "\nIf desired, you can disable it from Settings > Apps & Features > App execution aliases.";
	}
	error(msg);
} else if (!f.isFile()) {
	// user pasted a directory. Check for python.exe or just python
	File[] potentials = f.listFiles((dir, name) -> name.toLowerCase().equals("python.exe") || name.toLowerCase().equals("python"));
	// no results or > 1 result == fail
	if (potentials.length != 1) {
		String msg = "The specified path to the Python executable is not a file: " + pythonExecPath;
		msg += "\nTried to find 'python.exe' or 'python', but couldn't locate a single result!";
		msg += "\nPlease append the file to execute and try again.";
		error(msg);
	}
	// update with corrected path
	set_pythonExecPath(potentials[0].getAbsolutePath());
}

try {
	py = new PySubProcess(pathToServerPy, pythonExecPath, redirectPyOutput);
	modifyPathAsNeeded();
} catch (Exception e) {
	error(e, "Problem with setting up Python Subprocess:");
}]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Attempt]]></ReturnType>
					<Id>1581016194646</Id>
					<Name><![CDATA[runFile]]></Name>
					<Description><![CDATA[Execute a Python file and get the output.<br>
@param preferredVersion One of the options for which Python version to run the file<br>
@param args The file path and any arguments to run (flags and values should be separate strings)<br>
@return Attempt with any outputs from running the file]]></Description>
					<X>600</X><Y>300</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[preferredVersion]]></Name>
						<Type><![CDATA[PythonCommandType]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[args]]></Name>
						<Type><![CDATA[String...]]></Type>
					</Parameter>
					<Body><![CDATA[if (!preferredVersion.equals(PythonCommandType.PYTHON_OTHER)) {
	
	String pyPath;
	try {
		pyPath = PySubProcess.findPythonPath(
							PySubProcess.convertToCommand(preferredVersion)
						);
	} catch (PyException e) {
		return new Attempt(e);
	}
	// add to args
	String[] tmp = new String[args.length+1];
	tmp[0] = pyPath;
	System.arraycopy(args, 0, tmp, 1, args.length);
	args = tmp;
}

ProcessBuilder pb = new ProcessBuilder(args);
String output = "";
String error = "";

try {
	Process proc = pb.start();
	output = IOUtils.toString(proc.getInputStream()).trim();
	error = IOUtils.toString(proc.getErrorStream()).trim();
} catch (IOException | NullPointerException e) {
	String msg = String.format("Exception with running the command: `%s`\nStack trace is as follows:\n%s",
		String.join(" ", pb.command()),
		ExceptionUtils.toStringStackTrace(e));
	return new Attempt(Attempt.RESULT_ERROR, msg);
}

Attempt attempt;
if (error.isEmpty()) {
	attempt = new Attempt(Attempt.RESULT_SUCCESSFUL, output);
} else {
	attempt = new Attempt(Attempt.RESULT_ERROR, error);
}
	
return attempt;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Attempt]]></ReturnType>
					<Id>1581020688077</Id>
					<Name><![CDATA[runFile]]></Name>
					<Description><![CDATA[Execute a Python file using the preferred version of the running environment.<br>
@param args The file path, and any arguments to run (flags and values should be separate strings)<br>
@return Attempt with any outputs from running the file]]></Description>
					<X>600</X><Y>360</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[args]]></Name>
						<Type><![CDATA[String...]]></Type>
					</Parameter>
					<Body><![CDATA[String[] tmp = new String[args.length+1];
tmp[0] = py.activePyPath;
System.arraycopy(args, 0, tmp, 1, args.length);

Attempt attempt = PyCommunicator.runFile(PythonCommandType.PYTHON_OTHER, tmp);
history.add(0, new Pair<String,Attempt>(Arrays.toString(tmp), attempt));
validateHistoryLimit();
return attempt;]]></Body>
				</Function>
				<Function AccessType="private" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1582829555051</Id>
					<Name><![CDATA[validateHistoryLimit]]></Name>
					<Description><![CDATA[Continues to remove the last entry in `history` until its size is at/under 500.]]></Description>
					<X>450</X><Y>100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[while (history.size() > 500)
	history.removeLast();]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1588104859912</Id>
					<Name><![CDATA[importProperties]]></Name>
					<Description><![CDATA[Tries to import the properties file and load it into the model's parameters; if the properties file does not exist, the `generateProperties` function is called.]]></Description>
					<X>300</X><Y>150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[String filename = PROPERTIES_FILENAME;
// First check if one exists in current directory.
// If not, set to the default location.
File f = new File(filename);
if (!f.exists())
	filename = getDefaultPropertiesPath();

// Check if properties exists.
// If not, generate.
f = new File(filename);
if (!f.exists())
	generateProperties();

try (InputStream input = new FileInputStream(filename)) {
	Properties prop = new Properties();
	prop.load(input);
	set_pythonCommandType(
		PythonCommandType.valueOf(prop.getProperty("command_type"))
	);
	set_pythonCommand(
		prop.getProperty("command")
	);
	set_pythonExecPath(
		prop.getProperty("exec_path")
	);
	set_throwErrorOnFailedAttempt(
		Boolean.valueOf(prop.getProperty("throw_error_on_failed_attempt"))
	);
	set_redirectPyOutput(
		Boolean.valueOf(prop.getProperty("redirect_py_output", "true"))
	);
} catch (IOException e) {
	error(e, "Exception when reading properties file");
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1588105438239</Id>
					<Name><![CDATA[generateProperties]]></Name>
					<Description><![CDATA[Builds the properties file at the default properties path (`getDefaultPropertiesPath`) and saves the current parameter values.]]></Description>
					<X>300</X><Y>250</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[String newFilePath = getDefaultPropertiesPath();
try {
	OutputStream output = new FileOutputStream(newFilePath);
    Properties prop = new Properties();

    // set the properties value
    prop.setProperty("command_type", String.valueOf(pythonCommandType));
    prop.setProperty("command", String.valueOf(pythonCommand));
    prop.setProperty("exec_path", String.valueOf(pythonExecPath));
    prop.setProperty("throw_error_on_failed_attempt", String.valueOf(throwErrorOnFailedAttempt));
	prop.setProperty("redirect_py_output", String.valueOf(redirectPyOutput));
    
    // save properties to project root folder
    prop.store(output, null);

} catch (FileNotFoundException fnf) {
	// no write access, just warn
	warning("The directory which Pypeline's jar file resides in does not have write access; properties file cannot be generated.");
} catch (IOException io) {
    io.printStackTrace();
}]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1589485728564</Id>
					<Name><![CDATA[getDefaultPropertiesPath]]></Name>
					<Description><![CDATA[@return The path to the properties file<br>
<br>
Note: The path will change based on where the exported library jar is stored (as the properties is designed to be generated next to the library jar file).]]></Description>
					<X>300</X><Y>200</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[String file = PROPERTIES_FILENAME;
try {
	URI parentURI = this.getClass().getProtectionDomain().getCodeSource().getLocation().toURI().resolve(".");
	String parentPath = Paths.get(parentURI).toString();
	file = Paths.get(parentPath, file).toString();
} catch (URISyntaxException ex) {
	ex.printStackTrace();
}
return file;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1597362027154</Id>
					<Name><![CDATA[toJson]]></Name>
					<Description><![CDATA[@param object Any data type that can be converted to JSON<br>
@return The JSON form of the given object, or `null` if an error was encountered<br>
<br>
Note that agents and agent populations are handled manually due to a recursive issue.<br>]]></Description>
					<X>330</X><Y>430</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[object]]></Name>
						<Type><![CDATA[Object]]></Type>
					</Parameter>
					<Body><![CDATA[return toJson(object, false);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1597362055799</Id>
					<Name><![CDATA[fromJson]]></Name>
					<Description><![CDATA[@param json A JSON string to be converted to a Java object<br>
@param clazz The class to convert the provided string to<br>
@return The object of the specified type (or `null` if errors were encountered)]]></Description>
					<CustomModifierCode><![CDATA[public static <T>]]></CustomModifierCode>                 	
					<X>300</X><Y>610</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Body><![CDATA[// use specialized function for agent types
if (Agent.class.isAssignableFrom(clazz) || AgentList.class.isAssignableFrom(clazz)) {
	traceln("Need to use `fromAgentJson` or `fromPopulationJson` for converting agents/agent populations (returning null)");
	return null;
}
	
T output = null;
try {
	output = objmapper.readValue(json, clazz);
} catch (IOException e) {
	e.printStackTrace();
}
return output;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1598376672663</Id>
					<Name><![CDATA[toAgentJson]]></Name>
					<Description><![CDATA[As Agent-types cannot be used with ObjectMapper by default due to a recursive error, this function extracts as much useful information as possible.]]></Description>
					<X>300</X><Y>490</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[agentObj]]></Name>
						<Type><![CDATA[Object]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[includeInvalidFields]]></Name>
						<Type><![CDATA[boolean]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[prettyprint]]></Name>
						<Type><![CDATA[boolean]]></Type>
					</Parameter>
					<Body><![CDATA[int type = agentType(agentObj);
if (type == 0) {
	// passed object is not an agent;
	// just use `toJson`
	return PyCommunicator.toJson(agentObj, prettyprint);
}

HashSet<Object> seenAgents = new HashSet<>();
// add to seen set
seenAgents.add(agentObj);


// passed object is a population of agents
if (type == 2) {
	AgentArrayList<Agent> pop = (AgentArrayList) agentObj;
	ArrayList<?> popList = agentPopToList(pop, includeInvalidFields, seenAgents);
	return PyCommunicator.toJson(popList, prettyprint);
}

// passed object is a single agent
Agent agent = (Agent) agentObj;
//traceln("Converting: %s (type: %s)", agent.getName(), agent.getClass());
HashMap<String, Object> map = agentToMap(agent, includeInvalidFields, seenAgents);
//traceln("...as map: %s\n", map);
return PyCommunicator.toJson(map, prettyprint);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[HashMap<String, Object>]]></ReturnType>
					<Id>1598473547292</Id>
					<Name><![CDATA[agentToMap]]></Name>
					<Description><![CDATA[Extracts all public fields from the given agent and puts it into a varname-to-varvalue map. ]]></Description>
					<X>330</X><Y>520</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[agent]]></Name>
						<Type><![CDATA[Agent]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[includeInvalidFields]]></Name>
						<Type><![CDATA[boolean]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[seenAgents]]></Name>
						<Type><![CDATA[HashSet<Object>]]></Type>
					</Parameter>
					<Body><![CDATA[//traceln("Converting agent '%s' of type: %s", agent.getName(), agent.getClass());

// map of name of var to field value
HashMap<String, Object> map = new HashMap<>();

// store index if part of population (individual agents will have index of -1)
//	(using internal prefixes ["_"], to not confuse w/any potential user vars of the same name)
if (agent.getIndex() >= 0)
	map.put("_index", agent.getIndex());

// generic agents should return immediately
if (agent.getClass().equals(Agent.class)) {
	return map;
}

// for custom agent types, use reflection to get all fields inside of agent
Field[] fields = agent.getClass().getDeclaredFields();
String name;
Object value;
for (Field field : fields) {
	name = field.getName();
	
	//traceln("Examining field named '%s' (type: %s)...", name, field.getType());
	//traceln("  -> %s - %s", field.getType().getPackageName(), field.getType().getSimpleName());
	
	// skip known internal or problematic fields
	//	(e.g., for the scale, connections, internal datasets, etc.)
	// also skip common classes with assumed insignificance (e.g., shapes)
	if (name.contains("_xjal") || name.startsWith("__") || skipJsonifying(field.getType())) {
		//traceln("\tSkipping!");
		continue;
	}
	
	try {
		//field.trySetAccessible(); 
		value = field.get(agent);
		//traceln("\tValue is of type: %s", value.getClass());
		if (value == null)
			continue;
		
		// skip if value is top-level agent
		if (value.equals(agent.getRootAgent())) {
			//traceln("\tSkipping!");
			continue;
		}
		
		// apply this agent func for single agents
		if (value instanceof Agent) {
			// skip if already seen
			if (seenAgents.contains(value)) {
				//traceln("\tSkipping!");
				continue;
			}
			//traceln("\tIS AGENT; CONVERTING TO MAP!");
			value = agentToMap((Agent)value, includeInvalidFields, seenAgents);
		}
		// apply other agent func for populations 
		else if (value instanceof AgentArrayList) {
			// skip if already seen
			if (seenAgents.contains(value)) {
				//traceln("\tSkipping!");
				continue;
			}
			//traceln("\tIS AGENTPOP; CONVERTING TO LIST!");
			value = agentPopToList((AgentArrayList)value, includeInvalidFields, seenAgents);
		}
		// handle when value is a collection/map holding an incompatible AnyLogic type
		else if (value instanceof Collection || value instanceof Map) {
			boolean skip = false;
			//traceln("\tCollection named '%s', of type %s", name, value.getClass());
			for (java.lang.reflect.Type type : ((ParameterizedType)field.getGenericType()).getActualTypeArguments()) {
				//traceln("\t\tType named: %s of class %s", type.getTypeName(), type.getClass());
				if (skipJsonifying( (Class)type )) {
					skip = true;
					break;
				}
			}
			if (skip) {
				//traceln("\tSkipping!");
				continue;
			}
		}
		//traceln("\t%s: Adding object of type: %s", name, value.getClass());
		// try custom serializer
		value = customClassSerializer(value);
		map.put(name, value);
	} catch (IllegalAccessException e) {
		if (includeInvalidFields) {
			map.put(name, null);
		}
	}
}
/*
traceln(":: summary of types ::");
map.forEach((k,v) -> traceln("'%s' -> %s (from: %s)", k, v.getClass().getSimpleName(), v.getClass().getPackageName()));
traceln(":: ................ ::");
*/
return map;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1598473943538</Id>
					<Name><![CDATA[agentType]]></Name>
					<Description><![CDATA[Classifies an object based on its underlying class: <br>
`0` for entirely Java types,<br>
`1` for single agents,<br>
`2` for agent populations,<br>
`3` for Java collections with agent elements]]></Description>
					<X>300</X><Y>460</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[agentObj]]></Name>
						<Type><![CDATA[Object]]></Type>
					</Parameter>
					<Body><![CDATA[if (agentObj instanceof Agent)
	return 1;
else if (agentObj instanceof AgentArrayList)
	return 2;
else if (agentObj instanceof Collection 
	&& ((Collection)agentObj).size() > 0)
	return 3;
return 0;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ArrayList<HashMap<String, Object>>]]></ReturnType>
					<Id>1598562546634</Id>
					<Name><![CDATA[agentPopToList]]></Name>
					<Description><![CDATA[Creates a list of Map objects, one for each converted agent in the population]]></Description>
					<X>330</X><Y>580</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[agentPop]]></Name>
						<Type><![CDATA[AgentArrayList<Agent>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[includeInvalidFields]]></Name>
						<Type><![CDATA[boolean]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[seenAgents]]></Name>
						<Type><![CDATA[HashSet<Object>]]></Type>
					</Parameter>
					<Body><![CDATA[//traceln("Converting pop of size %s, type: %s", agentPop.size(), agentPop.getClass());

// list of agent map objects
ArrayList<HashMap<String, Object>> popList = new ArrayList<>();
agentPop.forEach(a -> {
	if (!seenAgents.contains(a)) {
		seenAgents.add(a);
		popList.add( PyCommunicator.agentToMap(a, includeInvalidFields, seenAgents) );
	}
});
return popList;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1598564953670</Id>
					<Name><![CDATA[runResults]]></Name>
					<Description><![CDATA[Evaluate an expression ("get value" / expecting a return)<br>
@param return_type The Java class of the return type<br>
@param code the single line of code to be executed<br>
@return T The output, in the type specified]]></Description>
					<CustomModifierCode><![CDATA[public <T>]]></CustomModifierCode>                 	
					<X>600</X><Y>210</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[return_type]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[code]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[Attempt attempt = py.eval(code);
history.add(0, new Pair<>(code, attempt));
validateHistoryLimit();
if (throwErrorOnFailedAttempt && !attempt.isSuccessful())
	error(attempt.getFeedback());
return attempt.getFeedback(return_type);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1598565117046</Id>
					<Name><![CDATA[runFile]]></Name>
					<Description><![CDATA[Execute a Python file and get the output.<br>
@param return_type The Java class of the return type<br>
@param preferredVersion One of the options for which Python version to run the file<br>
@param args The file path and any arguments to run (flags and values should be separate strings)<br>
@return T The output, in the type specified]]></Description>
					<CustomModifierCode><![CDATA[public static <T>]]></CustomModifierCode>                 	
					<X>630</X><Y>330</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[return_type]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[preferredVersion]]></Name>
						<Type><![CDATA[PythonCommandType]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[args]]></Name>
						<Type><![CDATA[String...]]></Type>
					</Parameter>
					<Body><![CDATA[Attempt attempt = runFile(preferredVersion, args);
return attempt.getFeedback(return_type);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1598565124530</Id>
					<Name><![CDATA[runFile]]></Name>
					<Description><![CDATA[Execute a Python file using the preferred version of the running environment.<br>
@param return_type The Java class of the return type<br>
@param args The file path, and any arguments to run (flags and values should be separate strings)<br>
@return T The output, in the type specified]]></Description>
					<CustomModifierCode><![CDATA[public <T>]]></CustomModifierCode>                 	
					<X>630</X><Y>390</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[return_type]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[args]]></Name>
						<Type><![CDATA[String...]]></Type>
					</Parameter>
					<Body><![CDATA[Attempt attempt = runFile(args);
return attempt.getFeedback(return_type);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1598565381265</Id>
					<Name><![CDATA[runResults]]></Name>
					<Description><![CDATA[Evaluate an expression ("get value" / expecting a return)<br>
@param return_type The Java class of the return type<br>
@param lines The multi-lined code to run, with each line as its own argument<br>
@return T The output, in the type specified]]></Description>
					<CustomModifierCode><![CDATA[public <T>]]></CustomModifierCode>                 	
					<X>630</X><Y>240</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[return_type]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[lines]]></Name>
						<Type><![CDATA[String...]]></Type>
					</Parameter>
					<Body><![CDATA[String code = String.join("\n", lines);
return runResults(return_type, code);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1598643746896</Id>
					<Name><![CDATA[toJson]]></Name>
					<Description><![CDATA[@param object Any data type that can be converted to JSON<br>
@param prettyprint Whether to output JSON in "pretty" format (with newlines, tabs, etc.)
@return The JSON form of the given object, or `null` if an error was encountered<br>
<br>
Note that agents and agent populations are handled manually due to a recursive issue.<br>]]></Description>
					<X>300</X><Y>400</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[object]]></Name>
						<Type><![CDATA[Object]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[prettyprint]]></Name>
						<Type><![CDATA[boolean]]></Type>
					</Parameter>
					<Body><![CDATA[String output = null;


int type = agentType(object);
if (type > 0) { // agent-type conversion
	if (type < 3) { // single agents or agent populations
		output = toAgentJson(object, false, prettyprint);
	} else { // Java list containing agents
		Collection collection = (Collection)object;
		String[] list = (String[])collection.stream()
			.map(a -> toJson(a, prettyprint))
			.toArray(String[]::new);
		String joiner = prettyprint ? ", " : ",";
		output = "[" + String.join(joiner, list) + "]";
	}
	return output;
}
// All other types should use object mapper
try {
	//traceln("Using objmap for: " + object.getClass());
	if (prettyprint)
		output = objmapper.writerWithDefaultPrettyPrinter().writeValueAsString(object);
	else
		output = objmapper.writeValueAsString(object);
} catch (JsonProcessingException e) {
	e.printStackTrace();
}
return output;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1599336077784</Id>
					<Name><![CDATA[fromAgentJson]]></Name>
					<Description><![CDATA[A function specifically for converting the given JSON to an agent class.<br>
(Using <code>fromJson</code> will result in a JsonMappingException regarding conflicting setter definitions for the proper "networkNode" (i.e., internal problems)<br>
@param json A JSON string to be converted to an AL agent<br>
@param clazz The class of the AL agent type to convert the provided string to<br>
@return The agent of the specified type (or `null` if errors were encountered)]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>300</X><Y>640</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Body><![CDATA[// Convert json to hashmap for name/value lookup
HashMap<String, Object> paramLookup = fromJson(json, HashMap.class);

// Get the generic agent contrustor
try {
	T myAgent = clazz
				.getDeclaredConstructor()
				.newInstance();
	paramLookup.forEach( (name,value) -> {
		// don't include custom key added to agent json in `agentPopToList`
		if (!name.equals("_index")) {
			// last arg is whether to trigger 'on change' callback of parameter
			((Agent)myAgent).setParameter(name, value, false);
		}
	});
	return myAgent;
} catch (InvocationTargetException | InstantiationException | NoSuchMethodException | IllegalAccessException e) {
	e.printStackTrace();
}

return null;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ArrayList]]></ReturnType>
					<Id>1599341550432</Id>
					<Name><![CDATA[fromPopulationJson]]></Name>
					<Description><![CDATA[A function specifically for converting the given JSON to an arraylist of agents.<br>
@param json A JSON string to be converted (should be a list of dicts, mapping parameter name to value)<br>
@param agent_clazz The class of the AL agent type<br>
@param owner The owner of the population (e.g., your root agent)<br>
@return AgentArrayList An access-only ArrayList of the agents]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>300</X><Y>700</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[agent_clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[owner]]></Name>
						<Type><![CDATA[Agent]]></Type>
					</Parameter>
					<Body><![CDATA[// Expected JSON is an array, where each element represents an agent's JSON
// (e.g., "[{"_index":0}, {"_index":1}]")
try {	
	// To properly get entirety of single agent, need to convert array to JsonNode
	JsonNode root = objmapper.readTree(json);
	// Build the output array based on the number of agent jsons detected
	ArrayList<T> newPop = new ArrayList();
	// Run each child json's string thru `fromAgentJson` and add to output array
	for (int i = 0; i < root.size(); i++) {
		JsonNode child = root.get(i);
		String childJson = objmapper.writeValueAsString(child);
		T childAgent = fromAgentJson(childJson, agent_clazz);
		newPop.add(childAgent);
	}
	return newPop;
} catch (Exception e) {
	e.printStackTrace();
}

return null;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1599503670262</Id>
					<Name><![CDATA[fromAgentJson]]></Name>
					<Description><![CDATA[A function specifically for converting the given JSON to an agent.<br>
(Using <code>fromJson</code> will result in a JsonMappingException regarding conflicting setter definitions for the proper "networkNode" (i.e., internal problems)<br>
@param json A JSON string to be converted to an AL agent<br>
@param clazz The class of the AL agent type to convert the provided string to<br>
@return The agent of the specified type (or `null` if errors were encountered)]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>330</X><Y>670</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[engine]]></Name>
						<Type><![CDATA[Engine]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[owner]]></Name>
						<Type><![CDATA[Agent]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[AgentArrayList]]></Type>
					</Parameter>
					<Body><![CDATA[// Convert json to hashmap for name/value lookup
HashMap<String, Object> paramLookup = fromJson(json, HashMap.class);


try {
	int index = population.size();
	
	T myAgent = clazz
				.getDeclaredConstructor(Engine.class, Agent.class, AgentList.class)
				.newInstance(engine, owner, population);
	population._add(myAgent);
	myAgent.markParametersAreSet();
	paramLookup.forEach( (name,value) -> {
		// don't include custom key added to agent json in `agentPopToList`
		if (!name.equals("_index")) {
			// last arg is whether to trigger 'on change' callback of parameter
			myAgent.setParameter(name, value, false);
		}
	});
	population.callCreate(myAgent, index);
	myAgent.start();
	return myAgent;
} catch (InvocationTargetException | InstantiationException | NoSuchMethodException | IllegalAccessException e) {
	e.printStackTrace();
}
return null;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[AgentArrayList]]></ReturnType>
					<Id>1599503959400</Id>
					<Name><![CDATA[fromPopulationJson]]></Name>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>330</X><Y>730</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[agent_clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[engine]]></Name>
						<Type><![CDATA[Engine]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[owner]]></Name>
						<Type><![CDATA[Agent]]></Type>
					</Parameter>
					<Body><![CDATA[// Expected JSON is an array, where each element represents an agent's JSON
// (e.g., "[{"_index":0}, {"_index":1}]")
try {	
	// To properly get entirety of single agent, need to convert array to JsonNode
	JsonNode root = objmapper.readTree(json);
	// Build the output array based on the number of agent jsons detected
	AgentArrayList<T> newPop = new AgentArrayList(owner);
	// Run each child json's string thru `fromAgentJson` and add to output array
	for (int i = 0; i < root.size(); i++) {
		JsonNode child = root.get(i);
		String childJson = objmapper.writeValueAsString(child);
		fromAgentJson(childJson, agent_clazz, engine, owner, newPop);
	}
	return newPop;
} catch (Exception e) {
	e.printStackTrace();
}

return null;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[AgentArrayList]]></ReturnType>
					<Id>1599504104781</Id>
					<Name><![CDATA[fromPopulationJson]]></Name>
					<Description><![CDATA[@deprecated
Converts an agent from JSON and adds it to an existing population.
@param json A valid JSON array, where each element represents a single agent's JSON object, mapping parameter names to values
@param agent_clazz The Java class for the agent type to convert to
@param engine The AnyLogic engine
@param owner The parent agent that the population belongs to
@param population The population to add the agent to]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>330</X><Y>760</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[agent_clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[engine]]></Name>
						<Type><![CDATA[Engine]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[owner]]></Name>
						<Type><![CDATA[Agent]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[AgentArrayList]]></Type>
					</Parameter>
					<Body><![CDATA[// Expected JSON is an array, where each element represents an agent's JSON
// (e.g., "[{"_index":0}, {"_index":1}]")
try {	
	// To properly get entirety of single agent, need to convert array to JsonNode
	JsonNode root = objmapper.readTree(json);
	// Run each child json's string thru `fromAgentJson` and add to output array
	for (int i = 0; i < root.size(); i++) {
		JsonNode child = root.get(i);
		String childJson = objmapper.writeValueAsString(child);
		fromAgentJson(childJson, agent_clazz, engine, owner, population);
	}
} catch (Exception e) {
	e.printStackTrace();
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1600284468018</Id>
					<Name><![CDATA[modifyPathAsNeeded]]></Name>
					<Description><![CDATA[Anaconda environments (including its base) add specific folders inside the environment to the system path before calling Python. Because Pypeline works through a "normal" command-prompt, these are not added in by default.<br>
If the 'conda-meta' directory - present in all Anaconda environments - is located in the same folder as the provided executable, this function will add all the paths that Anaconda does. Like Anaconda, this may include directories that don't exist on the user's machine (has no effect, though).<br>]]></Description>
					<X>300</X><Y>300</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[// Check if this is a conda environment by looking for 'conda-meta' dir
// 	in same folder as executable path.
File execFile = new File(pythonExecPath);
File parentDir = execFile.getParentFile();
String[] siblingFilenames = parentDir.list();
boolean contains = Arrays.stream(siblingFilenames).anyMatch("conda-meta"::equals);
if (contains) {
	//traceln("Adding!");
	run("import os");
	String pathStrs = "";
	String base = parentDir.getAbsolutePath() + parentDir.separator;
	for (String[] pathParts : condaPaths) {
		pathStrs += base + String.join(parentDir.separator, pathParts);
		pathStrs += parentDir.pathSeparator;
	}
	//traceln("Adding: " + pathStrs);
	run(
		String.format(
			"os.environ['PATH'] = r'%s' + os.environ['PATH']",
			pathStrs
	));
	//traceln("Added: " + runResults(String.class, "os.environ['PATH']"));
} else {
	//traceln("Not adding!");
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[AgentArrayList]]></ReturnType>
					<Id>1605754486288</Id>
					<Name><![CDATA[fromPopulationJson]]></Name>
					<Description><![CDATA[Converts a list of agents from JSON and adds it to an existing population.
@param json A valid JSON array, where each element represents a single agent's JSON object, mapping parameter names to values
@param agent_clazz The Java class for the agent type to convert to
@param population The population to add the agent to]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>330</X><Y>790</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[agent_clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[AgentArrayList]]></Type>
					</Parameter>
					<Body><![CDATA[// Expected JSON is an array, where each element represents an agent's JSON
// (e.g., "[{"_index":0}, {"_index":1}]")
try {	
	// To properly get entirety of single agent, need to convert array to JsonNode
	JsonNode root = objmapper.readTree(json);
	// Run each child json's string thru `fromAgentJson` and add to output array
	for (int i = 0; i < root.size(); i++) {
		JsonNode child = root.get(i);
		String childJson = objmapper.writeValueAsString(child);
		fromAgentJson(childJson, agent_clazz, population.getOwner().getEngine(), population.getOwner(), population);
	}
} catch (Exception e) {
	e.printStackTrace();
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Object]]></ReturnType>
					<Id>1605756231379</Id>
					<Name><![CDATA[customClassSerializer]]></Name>
					<Description><![CDATA[Tries to convert the given object to a serializable format that Jackson can understand.
@return a generic object that should be serializable (or the original object if not handled)]]></Description>
					<X>360</X><Y>550</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[object]]></Name>
						<Type><![CDATA[Object]]></Type>
					</Parameter>
					<Body><![CDATA[if (object instanceof StatisticsDiscrete) {
	return serializeStatisticsDiscrete((StatisticsDiscrete)object);
} else if (object instanceof StatisticsContinuous) {
	return serializeStatisticsContinuous((StatisticsContinuous)object);
} else if (object instanceof HistogramData) {
	return serializeHistogram1DData((HistogramData)object);
} else if (object instanceof Histogram2DData) {
	return serializeHistogram2DData((Histogram2DData)object);
}
return object;]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1569858524850</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>


			<Presentation>
				<Level>
					<Id>1569858524854</Id>
					<Name><![CDATA[level]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<Z>0</Z>
					<LevelVisibility>DIM_NON_CURRENT</LevelVisibility>

			<Presentation>
				<Image>
					<Id>1582833534630</Id>
					<Name><![CDATA[image2]]></Name>
					<X>5</X><Y>5</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<OnClickCode><![CDATA[return true;]]></OnClickCode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<Width>32</Width>
					<Height>32</Height>
					<Rotation>0.0</Rotation>
					<ImageFiles>
						<ImageResourceReference>
							<PackageName><![CDATA[com.anylogic.libraries.pypeline]]></PackageName>
							<ClassName><![CDATA[Python-logo.png]]></ClassName>
						</ImageResourceReference>
					</ImageFiles>
					<OriginalSize>true</OriginalSize>
				</Image>
			</Presentation>

				</Level>
			</Presentation>

		</ActiveObjectClass>
	</ActiveObjectClasses>	
	<DifferentialEquationsMethod>EULER</DifferentialEquationsMethod>
	<MixedEquationsMethod>RK45_NEWTON</MixedEquationsMethod>
	<AlgebraicEquationsMethod>MODIFIED_NEWTON</AlgebraicEquationsMethod>
	<AbsoluteAccuracy>1.0E-5</AbsoluteAccuracy>
	<FixedTimeStep>0.001</FixedTimeStep>
	<RelativeAccuracy>1.0E-5</RelativeAccuracy>
	<TimeAccuracy>1.0E-5</TimeAccuracy>
	<Frame>
		<Width>1000</Width>
		<Height>600</Height>
	</Frame>
	<Database>
		<Logging>false</Logging>
		<AutoExport>false</AutoExport>
		<ShutdownCompact>false</ShutdownCompact>
		<ImportSettings>
		</ImportSettings>
		<ExportSettings>
		</ExportSettings>
	</Database>
	
	<RunConfiguration ActiveObjectClassId="1569858524855">
		<Id>1567802082277</Id>
		<Name><![CDATA[RunConfiguration]]></Name>
		<MaximumMemory>512</MaximumMemory>
		<ModelTimeProperties>
			<StopOption><![CDATA[Stop at specified time]]></StopOption>
			<InitialDate><![CDATA[1567728000000]]></InitialDate>	
			<InitialTime><![CDATA[0.0]]></InitialTime>	
			<FinalDate><![CDATA[1570320000000]]></FinalDate>	
			<FinalTime><![CDATA[100.0]]></FinalTime>	
		</ModelTimeProperties>
		<AnimationProperties>
			<StopNever>true</StopNever>
			<ExecutionMode>realTimeScaled</ExecutionMode>
			<RealTimeScale>1.0</RealTimeScale>
			<EnableZoomAndPanning>true</EnableZoomAndPanning>
			<EnableDeveloperPanel>false</EnableDeveloperPanel>
			<ShowDeveloperPanelOnStart>false</ShowDeveloperPanelOnStart>
		</AnimationProperties>
		<Inputs>		
		</Inputs>
		<Outputs>
		</Outputs>
	</RunConfiguration>
	<Experiments>	
		<!--   =========   Simulation Experiment   ========  -->
		<SimulationExperiment ActiveObjectClassId="1569858524855">
			<Id>1574367440449</Id>
			<Name><![CDATA[Simulation]]></Name>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<CommandLineArguments><![CDATA[]]></CommandLineArguments>
			<MaximumMemory>512</MaximumMemory>
			<RandomNumberGenerationType>fixedSeed</RandomNumberGenerationType>
			<CustomGeneratorCode>new Random()</CustomGeneratorCode>
			<SeedValue>1</SeedValue>
			<SelectionModeForSimultaneousEvents>LIFO</SelectionModeForSimultaneousEvents>
			<VmArgs><![CDATA[]]></VmArgs>
			<LoadRootFromSnapshot>false</LoadRootFromSnapshot>

			<Presentation>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text]]></Name>
					<X>50</X><Y>30</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12490271</Color>
					<Text><![CDATA[Pypeline Library]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>24</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
			</Presentation>

			<Parameters>			
				<Parameter>
					<ParameterName><![CDATA[loadLastWorkingConfig]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[pythonCommandType]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[pythonCommand]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[pythonExecPath]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[throwErrorOnFailedAttempt]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[redirectPyOutput]]></ParameterName>
				</Parameter>
			</Parameters>			
			<PresentationProperties>
				<EnableZoomAndPanning>true</EnableZoomAndPanning>
				<ExecutionMode><![CDATA[realTimeScaled]]></ExecutionMode>
				<Title><![CDATA[Pypeline Library : Simulation]]></Title>	
				<EnableDeveloperPanel>true</EnableDeveloperPanel>
				<ShowDeveloperPanelOnStart>false</ShowDeveloperPanelOnStart>
				<RealTimeScale>1.0</RealTimeScale>
			</PresentationProperties>
			<ModelTimeProperties>
				<StopOption><![CDATA[Never]]></StopOption>
				<InitialDate><![CDATA[1574294400000]]></InitialDate>	
				<InitialTime><![CDATA[0.0]]></InitialTime>	
				<FinalDate><![CDATA[1576886400000]]></FinalDate>	
				<FinalTime><![CDATA[100.0]]></FinalTime>	
			</ModelTimeProperties>
			<BypassInitialScreen>false</BypassInitialScreen>
		</SimulationExperiment>	
	</Experiments>
	<JavaClasses>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1569858562164</Id>
			<Name><![CDATA[PySubProcess]]></Name>
			<Text><![CDATA[import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.ObjectStreamException;
import java.io.OutputStream;
import java.net.Socket;
import java.nio.file.Paths;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.lang.ProcessBuilder.Redirect;
import java.net.URL;
import spark.utils.IOUtils;


/**
 * This object is created in the main communicator agent and works as the 'middleman' between your model and Python.
 * Specifically, it works by first locating your Python executable, then using that to start the server.py file.
 * Once it does that, it listens for what port the Python server is listening on (which it communicates via i/o streams) and then connects as a client.
 * It is then able to receive code passed from an AnyLogic model and communicates that to the Python server.
 * 
 * @author Tyler Wolfe-Adam
 */
public class PySubProcess {
	
	// the command that will be used to locate python - will be different for windows vs mac/linux
	public static final String findCmd = System.getProperty("os.name").toLowerCase().contains("win") ? "where" : "which";
	// the path to the python executable
	public String activePyPath = "";
	public String activePyVersion = "";
	public boolean redirectPyOutput;
	
	// out types
	public final static byte execMsg = 0;
	public final static byte evalMsg = 1;
	public final static byte pingMsg = 2;
	
	// in types
	public final static int successMsg = 0;
	public final static int errorMsg = 1;
	
	public Process proc = null;
	public Socket socket = null;
	
	public InputStream in = null;
	public OutputStream out = null;
	
	public InputStream stdout = null;
	public InputStream stderr = null;
	
	public ExecutorService executor = null;
    
    /**
     * 
     * @param pathToPyExe
     * @param pathToServerPy
     */
    public PySubProcess(String pathToServerPy, String pathToPyExe, boolean redirectPyOutput) throws IOException, PyException, InterruptedException {
    	activePyPath = pathToPyExe;
    	activePyVersion = getPythonVersion(activePyPath);
    	this.redirectPyOutput = redirectPyOutput;
	    initConnection(pathToServerPy);
		openStreams();
    }
    
    /**
     * 
     * @param pathToServerPy
     * @throws IOException
     * @throws Exception
     */
    private void initConnection(String pathToServerPy) throws IOException, PyException, InterruptedException {
    	// First find/validate the path to the server.py file
    	final String serverPyFile = "server.py";
    	File workingDirectory = new File(System.getProperty("user.dir"));

    	// TODO - is the following needed? server.py is always a temp file with full dir given
    	if (pathToServerPy == null) // in case nothing was given, check in working directory
    		pathToServerPy = Paths.get(workingDirectory.toString(), serverPyFile).toString();
    	else if (!pathToServerPy.endsWith(".py")) // in case just directory was given
    		pathToServerPy = Paths.get(pathToServerPy, serverPyFile).toString();
    	
    	if (!new File(pathToServerPy).exists()) {
    		throw new IOException("Path to server python file does not exist: " + pathToServerPy);
    	}
    	
    	// Build and execute the command to run the server.py file
    	List<String> pythonCmd = Arrays.asList(activePyPath, pathToServerPy);
		ProcessBuilder pb = new ProcessBuilder(formatCommand(pythonCmd)).directory(workingDirectory);
		
		proc = pb.start();

		// The server.py file will print the port it's using to the standard output.
		// Capture the port it's using.
		String portLine = null;
		BufferedReader pbInput = new BufferedReader(new InputStreamReader(proc.getInputStream()));
		portLine = pbInput.readLine();
		if (portLine == null) {
			//BufferedReader pbError = new BufferedReader(new InputStreamReader(proc.getErrorStream()));
			String errorMsg = IOUtils.toString(proc.getErrorStream());
			throw new IOException("Input returned null; Error stream line reads: " + errorMsg);
		}
		
		int port = Integer.MIN_VALUE;
		try {
			port = Integer.parseInt(portLine);
		} catch (NumberFormatException e) {
			earlyFail("Python process did not provide a port to connect with -- are you using a valid Python executable?; read line: " + portLine);
		}
		
		// Connect to the server.py file via socket
		while (socket == null && proc.isAlive()) {
			try {
				socket = new Socket("localhost", port);
			} catch (IOException e) {
				// keep trying
				Thread.sleep(100);
			}
		}
		
		// Make sure the process is alive and running
		if (!proc.isAlive()) {
			earlyFail("Python process failed to start:");
		}
	}
    
    /**
     * Open the streams to and from the Python server
     */
    private void openStreams() {
    	try {
			in = socket.getInputStream();
			out = socket.getOutputStream();
			stdout = proc.getInputStream();
			stderr = proc.getErrorStream();
			executor = Executors.newSingleThreadExecutor();
		} catch (IOException e) {
			e.printStackTrace();
		}
    }
    
    /**
     * Generate an early failure with some given prefix text.
     * Useful, as it will also provide stdout and stderr.
     * @param prefix
     * @throws Exception
     */
    void earlyFail(String prefix) throws IOException, PyException {
		String stdoutOutput = readAllReady(new InputStreamReader(proc.getInputStream()));
		String stderrOutput = readAllReady(new InputStreamReader(proc.getErrorStream()));
		throw new PyException("[ERROR] " + prefix + (prefix.endsWith("\n") ? "" : "\n")
				+ (stderrOutput.isEmpty() ? "" : "Error stream message:\n" + stderrOutput)
				+ (stdoutOutput.isEmpty() ? "" : "Output stream message:\n" + stdoutOutput));
	}
    
    /**
     * Just ping the Python server to make sure it's still running.
     * @return Attempt
     */
    public Attempt ping() {
    	try {
	    	out.write(pingMsg);
			out.flush();

	    	return readAttemptResult();
    	} catch (Throwable e) { // catchall
    		return new Attempt(e);
    	}
    	
    }
    
    /**
     * Execute a statement ("just run" / no expected return, other than the return code)
     * @param stmt The code to be executed
     * @return Attempt With empty feedback if successful, otherwise the error message
     */
    public Attempt exec(String stmt) {
    	try {
			out.write(execMsg);
			writeString(stmt);
			out.flush();
	    	return readAttemptResult();
    	} catch (Throwable e) { // catchall
    		return new Attempt(e);
    	}
	}
	
    /**
     * Evaluate an expression ("get value" / expecting a return)
     * @param expr the code to be evaluated
     * @return Attempt With a feedback of the returned value if no error, otherwise the error message
     */
	public Attempt eval(String expr) {
		try {
			out.write(evalMsg);
			writeString(expr);
			out.flush();
			
	    	return readAttemptResult();
		} catch (Exception e) {
			return new Attempt(e);
		}
	}
    
    private Attempt readAttemptResult() throws IOException {
    	// Continue to dump standard input and standard error of process until received data from Python.
    	// Unhandled warn statements will block process from continuing (and are piped to standard error)
    	while (in.available() == 0) {
    		printStdout();
    		printStderr();
    	}
    	
    	byte resultCode = readByte();
    	String feedback = readString();
    	
    	printStdout();
    	printStderr();
    	
    	Attempt result = new Attempt(resultCode, feedback);
    	return result;
    }
    
    
    /**
     * Prints anything from the standard input stream (from the process)
     * @return String
     */
    private void printStdout() throws IOException {
    	// Display anything Python put into stdout (e.g., print statements)
    	int n = stdout.available();
    	if (n > 0) {
    		byte[] b = new byte[n];
    		stdout.read(b);
    		String s = (new String(b)).trim();
    		// start each line with '> ' to distinguish it for Console viewers
    		s = "> " + s.replaceAll("(\\r\\n|\\r|\\n)", "$1> ");
    		if (redirectPyOutput)
    			traceln(green, s);
    	}
    }
    
    /**
     * Prints anything from the standard error stream (from the process)
     * @return String
     */
    private void printStderr() throws IOException {
    	// Display anything Python put into stderr, that's not an exception/error (e.g., warn statements)
    	int n = stderr.available();
    	if (n > 0) {
    		byte[] b = new byte[n];
    		stderr.read(b);
    		String s = (new String(b)).trim();
    		// start each line with '> ' to distinguish it for Console viewers
    		s = "> " + s.replaceAll("(\\r\\n|\\r|\\n)", "$1> ");
    		if (redirectPyOutput)
    			traceln(red, s);
    	}
    }
	
	/**
	 * Read a number of bytes from the in stream
	 * @param numBytes how many bytes to read
	 * @return byte[]
	 * @throws IOException
	 */
	byte[] read(int numBytes) throws IOException {
		byte[] output = new byte[numBytes];
		for (int i = 0; i < numBytes; i++)
			output[i] = readByte();
		return output;
	}
	
	/**
	 * Read a single byte from the in stream
	 * @return byte
	 * @throws IOException
	 */
	byte readByte() throws IOException {
		int nextByte = in.read();
		if (nextByte == -1) {
			throw new IOException("Cannot read byte; reached end of stream");
		}
		return (byte) nextByte;
	}
	
	/**
	 * Read an integer (4 bytes) from the in stream
	 * @return int
	 * @throws IOException
	 */
	int readInt() throws IOException {
		return (readByte() << 24) & 0xff000000 |
				(readByte() << 16) & 0x00ff0000 | 
				(readByte() <<  8) & 0x0000ff00 |
				(readByte() <<  0) & 0x000000ff;
	}
	
	/**
	 * Read a string from the in stream (by first reading an integer to see how long the string will be)
	 * @return String
	 * @throws IOException
	 */
	String readString() throws IOException {
		int len = readInt();
		String output = new String(read(len), "UTF-8");
		return output;
	}
	
	/**
	 * Write an integer to the out stream
	 * @param i
	 * @throws IOException
	 */
	void writeInt(int i) throws IOException {
		byte[] b = new byte[] {
				(byte) (i >>> 24),
				(byte) (i >>> 16),
				(byte) (i >>> 8),
				(byte) i
		};
		out.write(b);
	}
	
	/**
	 * Write a string to the out stream (but first write the size [in bytes] as an integer)
	 * @param str
	 * @throws IOException
	 */
	void writeString(String str) throws IOException {
		byte[] b = str.getBytes();
		writeInt(b.length);
		out.write(b);
	}
	
	/**
	 * Close all streams and processes
	 * @throws Exception
	 */
	void close() throws Exception {
		executor.shutdownNow();
		// close down streams, ignoring if they throw errors
		try {
			in.close();
		} catch (IOException e) {}
		
		try {
			out.close();
		} catch (IOException e) {}
		
		try {
			socket.close();
		} catch (IOException e) {}
		
		proc.destroyForcibly();
		try {
			proc.waitFor(3, TimeUnit.SECONDS);
		} catch (InterruptedException e) {}
		if (proc.isAlive())
			throw new Exception("Python process failed to shutdown. Please shut it down via your process manager");
		
	}
	
	/**
	 * Helper function to format the command based on the operating system
	 * @param args
	 * @return List<String>
	 */
	public static List<String> formatCommand(List<String> args) {
		String os = System.getProperty("os.name").toLowerCase();
		/* TODO Why was this needed? Seemed to be causing problems, so removed for now.
		if (os.contains("mac")) {
			args.replaceAll(s -> "'" + s + "'");
			args.addAll(0, new ArrayList<>(Arrays.asList("/bin/bash", "-l", "-c")));
		}
		*/
		return args;
	}
	
	/**
	 * Read all ready strings
	 * @param in
	 * @return String
	 * @throws IOException
	 */
	public static String readAllReady(InputStream in) throws IOException {
		return readAllReady(new InputStreamReader(in));
	}
	
	/**
	 * Read all ready strings
	 * @param inReader
	 * @return String
	 * @throws IOException
	 */
	public static String readAllReady(InputStreamReader inReader) throws IOException {
		StringBuilder sbuilder = new StringBuilder();
		while (inReader.ready())
			sbuilder.append((char)inReader.read());
		return sbuilder.toString();
	}
	
	
	/**
	 * Helper function to convert the enum to the Python command
	 * @param preferredCommand
	 * @return String
	 */
	public static String convertToCommand(PythonCommandType preferredCommand) {
		switch (preferredCommand) {
			case PYTHON:
				return "python";
			case PYTHON2:
				return "python2";
			case PYTHON3:
				return "python3";
			default:
				return null;
		}
	}
	
	/**
	 * Locate the executable in user's path by running the 'find' command (or the OS-equivalent)
	 * @param pythonCommand
	 * @return String
	 */
	public static String findPythonPath(String pythonCommand) throws PyException {
		ProcessBuilder pb = new ProcessBuilder(findCmd, pythonCommand);
		pb.redirectError(Redirect.PIPE);
		pb.redirectInput(Redirect.PIPE);
		String loc = null;
		try {
			Process proc = pb.start();
			BufferedReader reader = new BufferedReader(new InputStreamReader(proc.getInputStream()));
			loc = reader.readLine();
		} catch (IOException e) {
			e.printStackTrace();
		} catch (NullPointerException e2) {
			throw new PyException("Failed to find Python path using command: " + pythonCommand);
		}
		return loc;
	}

	
	/**
	 * Helper function to get the specified Python version.
	 * (Just calls Python with the `--version` flag)
	 * @param pythonPath The path to the desired Python executable
	 * @return String
	 */
	public static String getPythonVersion(String pythonPath) throws IOException {
		ProcessBuilder pb = new ProcessBuilder(pythonPath, "--version");
		pb.redirectError(Redirect.PIPE);
		pb.redirectInput(Redirect.PIPE);

		Process proc = pb.start();
		BufferedReader reader = new BufferedReader(new InputStreamReader(proc.getInputStream()));
		String version = reader.readLine();

		// There's weird behavior when running on Mac's built-in Python 2,
		//	where the version gets printed out in the error stream (and input stream is null).
		// Handle if applicable.
		if (version == null)
			version = new BufferedReader(new InputStreamReader(proc.getErrorStream())).readLine();
		
		return version;
	}
	
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1569861582393</Id>
			<Name><![CDATA[Attempt]]></Name>
			<Text><![CDATA[import java.util.Arrays;
import java.io.IOException;
import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * This object represents the results from the attempt that was made to execute some Python code.
 * It has two basic objects: one for determining the success of the command and the other for the response with additional data (referred to as the "feedback").<br>
 * If the code executed without errors, the feedback will contain either the requested data or some message indicating the success (depending on if using `run` or `runResults`).<br>
 * Otherwise, the feedback will contain the error message - this could be from Python or Java, depending on the specific problem.<br>
 * 
 * The following examples show what function is called and its argument, followed by what would be printed to the console.<br>
 * Some also have additional comments underneath to explain the results.<br>
 * Examples:<br>
 * &emsp; runResults("3+5") -> Attempt [isSuccessful=true, feedback=8]<br>
 * &emsp; run("3+5") -> Attempt [isSuccessful=true, feedback=]<br>
 * &emsp; run("3..5") -> Attempt [isSuccessful=false, feedback=SyntaxError('invalid syntax', ('<string>', 1, 4, '3..5\n'))]<br>
 * &emsp; runResults("foo()") -> Attempt [isSuccessful=false, feedback=NameError("name 'foo' is not defined",)]<br>
 * &emsp; run("def foo():", "  return 'hello'") -> Attempt [isSuccessful=true, feedback=]<br>
 * &emsp; runResults("foo()") -> Attempt [isSuccessful=true, feedback=hello]<br>
 * 
 * @author Tyler Wolfe-Adam
 */
public class Attempt {
	
	public static final int RESULT_SUCCESSFUL = 0;
	public static final int RESULT_ERROR = 1;
	
	private final int resultCode;
	private final String feedback;
	
	/**
	 * Initialize a new Attempt object as having been successful with null feedback
	 */
	public Attempt() {
		this(RESULT_SUCCESSFUL, null);
	}
	
	public Attempt(Throwable e) {
		this(RESULT_ERROR, e.getMessage());
	}
	
	/**
	 * Initialize a new Attempt object as determined by the arguments
	 * @param resultCode The static int indicating if the command executed successfully
	 * @param feedback The response received from running the command associated with this object
	 */
	public Attempt(int resultCode, String feedback) {
		this.resultCode = resultCode;
		this.feedback = feedback;
	}

	/**
	 * Stringified version of this object
	 */
	@Override
	public String toString() {
		String isSuccStr = String.valueOf(isSuccessful());
		return String.format("Attempt [isSuccessful=%s, feedback=%s]", isSuccStr, getFeedback());
	}

	/**
	 * @return whether or not this command executed successfully
	 */
	public boolean isSuccessful() {
		return resultCode == RESULT_SUCCESSFUL;
	}
	
	/**
	 * @return the result code of the command associated with this Attempt
	 */
	public int getResultCode() {
		return resultCode;
	}

	/**
	 * @return the feedback received from Python after executing the command
	 */
	public String getFeedback() {
		return getFeedback(String.class);
	}

	/**
	 * @param type the class to cast the object to
	 * @return the feedback from executing the command, casted to the specified type
	 */
	public <T> T getFeedback(Class<T> type) {
		if (type == null || type.equals(String.class)) { 
			return (T) feedback;
		} else if (type.equals(Byte.class)) {
			return type.cast(Byte.valueOf(feedback));
		} else if (type.equals(Short.class)) {
			return type.cast(Short.valueOf(feedback));
		} else if (type.equals(Integer.class)) {
			return type.cast(Integer.valueOf(feedback));
		} else if (type.equals(Long.class)) {
			return type.cast(Long.valueOf(feedback));
		} else if (type.equals(Float.class)) {
			return type.cast(Float.valueOf(feedback));
		} else if (type.equals(Double.class)) {
			return type.cast(Double.valueOf(feedback));
		} else if (type.equals(Boolean.class)) {
			return type.cast(Boolean.valueOf(feedback));
		} else { // assume feedback is json
			ObjectMapper mapper = new ObjectMapper();
			try {
				return mapper.readValue(feedback, type);
			} catch (IOException e) {
				//e.printStackTrace();
			}
		}
		
		return type.cast(feedback);
	}
}
]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1589584967334</Id>
			<Name><![CDATA[PyException]]></Name>
			<Text><![CDATA[/**
 * Custom (generic) exception class
 */
public class PyException extends Exception { 
    public PyException(String errorMessage) {
        super(errorMessage);
    }
}]]></Text>
		</JavaClass>
	</JavaClasses>
	<Libraries>
		<!--   =========   Library   ========  -->
		<Library>
			<Id>1567903824199</Id>
			<Name><![CDATA[Pypeline]]></Name>
			<Description><![CDATA[The library that allows you to run Python code within AnyLogic model.]]></Description>
			<AOCEntry>
				<ActiveObjectClassId>1569858524855</ActiveObjectClassId>
				<Icon16ResourceReference>
					<PackageName><![CDATA[com.anylogic.libraries.pypeline]]></PackageName>
					<ClassName><![CDATA[Python-logo-16.png]]></ClassName>
				</Icon16ResourceReference>
				<Icon32ResourceReference>
					<PackageName><![CDATA[com.anylogic.libraries.pypeline]]></PackageName>
					<ClassName><![CDATA[Python-logo-32.png]]></ClassName>
				</Icon32ResourceReference>
			</AOCEntry>

			<IconResourceReference>
				<PackageName><![CDATA[com.anylogic.libraries.pypeline]]></PackageName>
				<ClassName><![CDATA[Pypeline-libicon.png]]></ClassName>
			</IconResourceReference>
			<VersionMajor>1</VersionMajor>
			<VersionMinor>4</VersionMinor>
			<VersionBuild>1</VersionBuild>
			<Provider><![CDATA[Tyler Wolfe-Adam]]></Provider>    
		</Library>
	</Libraries>
	<ModelResources>
		<Resource>
			<Path><![CDATA[Python-logo-16.png]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
		</Resource>
		<Resource>
			<Path><![CDATA[Python-logo-32.png]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
		</Resource>
		<Resource>
			<Path><![CDATA[Python-logo.png]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
		</Resource>
		<Resource>
			<Path><![CDATA[Pypeline-libicon.png]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
		</Resource>
	</ModelResources>
    <RequiredLibraryReference>
		<LibraryName><![CDATA[com.anylogic.libraries.modules.markup_descriptors]]></LibraryName>
		<VersionMajor>1</VersionMajor>
		<VersionMinor>0</VersionMinor>
		<VersionBuild>0</VersionBuild>
    </RequiredLibraryReference>
</Model>
</AnyLogicWorkspace>